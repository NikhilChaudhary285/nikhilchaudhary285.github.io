<!-- ================= ENGINEERING ================= -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Engineering | Nikhil Chaudhary</title>

    <!-- SEO -->
    <meta name="description" content="Engineering philosophy, multiplayer architecture, optimization mindset, and system design by Unity Multiplayer Game Developer Nikhil Chaudhary." />
    <meta name="author" content="Nikhil Chaudhary" />

    <!-- CSS -->
    <link rel="stylesheet" href="css/style.css" />
</head>

<body>

<!-- ================= NAVBAR ================= -->
<nav class="navbar" role="navigation" aria-label="Main navigation">
    <div class="nav-container">

        <div class="nav-logo">
            <a href="index.html"><span>Nikhil Chaudhary</span></a>
        </div>

        <ul class="nav-links" id="navLinks">
            <li><a href="index.html">Home</a></li>
            <li><a href="about.html">About</a></li>
            <li><a href="projects.html">Projects</a></li>
            <li><a href="engineering.html" class="nav-cta active">Engineering</a></li>
            <li><a href="case-study/foundation-projects.html">Foundation</a></li>
            <li><a href="resume.html">Resume</a></li>
            <li><a href="contact.html">Contact</a></li>
        </ul>

        <button class="nav-toggle" id="navToggle" aria-label="Toggle menu">
            ☰
        </button>
    </div>
</nav>

<!-- ================= HEADER ================= -->
<header class="hero">
    <div class="container">
        <h1>Engineering Philosophy</h1>
        <p class="hero-description">
            How I design <strong>scalable multiplayer systems</strong>,
            write <strong>maintainable Unity architecture</strong>,
            and optimize games for <strong>real-world production</strong>.
        </p>
    </div>
</header>

<!-- ================= INTRO ================= -->
<section>
    <p>
        I approach Unity development as <strong>software engineering</strong>,
        not just game scripting.
        Every system I build is designed to be
        <strong>understandable, extendable, and production-ready</strong>.
    </p>
</section>

<!-- ================= ARCHITECTURE ================= -->
<section>
    <h3>1. Clean Architecture in Unity</h3>
    <p>
        I structure Unity projects around <strong>clear responsibility boundaries</strong>
        instead of scene-driven logic.
    </p>

    <ul>
        <li>Separation of UI, gameplay, networking, and data layers</li>
        <li>MVP pattern for UI-heavy systems (menus, lobbies, HUDs)</li>
        <li>ScriptableObjects for stats, configs, and reusable data</li>
        <li>Singletons used intentionally (SessionManager, NetworkManager)</li>
    </ul>

    <p>
        This keeps systems testable, readable, and scalable as projects grow.
    </p>
</section>

<!-- ================= MULTIPLAYER ================= -->
<section>
    <h3>2. Multiplayer Architecture (Photon PUN & Socket.IO)</h3>

    <p>
        Multiplayer engineering is about <span class="highlight">state consistency</span>,
        latency tolerance, and maintaining <span class="highlight">player trust</span>
        across unreliable network conditions.
    </p>

    <p><strong>Core multiplayer systems I design and implement:</strong></p>
    <ul>
        <li>Room-based architecture with dynamic player counts (1–4 players)</li>
        <li>Player-ready state synchronization before gameplay begins</li>
        <li>Master-client authority where deterministic control is required</li>
        <li>Scene synchronization using <strong>AutomaticallySyncScene</strong></li>
    </ul>

    <p>
        For real-time game state consistency, I prefer
        <strong>Photon Custom Room Properties</strong> and
        <strong>RaiseEvent</strong> for deterministic synchronization,
        intentionally avoiding excessive RPC usage to reduce network noise.
    </p>

    <p>
        Alongside Photon, I also work with <span class="highlight">Socket.IO</span>
        for backend-driven real-time systems such as:
    </p>

    <ul>
        <li>Player presence, session tracking, and server-side events</li>
        <li>Lobby-level messaging and non-gameplay real-time updates</li>
        <li>Secure client–server communication using event-based architecture</li>
    </ul>

    <p>
        This hybrid approach allows me to separate
        <span class="highlight">gameplay synchronization</span>
        from <span class="highlight">backend communication</span>,
        resulting in cleaner architecture and better scalability.
    </p>

    <div>
        <span class="pill"> • Photon PUN • </span>
        <span class="pill">Socket.IO • </span>
        <span class="pill">Room Properties • </span>
        <span class="pill">RaiseEvent • </span>
        <span class="pill">Real-Time Systems</span>
    </div>
</section>


<!-- ================= AI ================= -->
<section>
    <h3>3. Modular AI Systems</h3>
    <p>
        Enemy behavior is built using a <strong>State + Strategy architecture</strong>
        instead of monolithic Update loops.
    </p>

    <ul>
        <li>State Machine: Idle, Move, Attack, Dead</li>
        <li>Strategy pattern for movement and targeting logic</li>
        <li>ScriptableObject-driven enemy stats and tuning</li>
        <li>Object pooling for enemies, bullets, and visual effects (VFX)</li>
    </ul>

    <p>
        This allows new enemy types without modifying existing core logic.
    </p>
</section>

<!-- ================= OPTIMIZATION ================= -->
<section>
    <h3>4. Performance & Optimization Mindset</h3>
    <p>
        Optimization is planned <strong>from day one</strong>,
        not treated as a late-stage fix.
    </p>

    <ul>
        <li>Object pooling to reduce runtime allocations</li>
        <li>Network data size reduction & compact serialization</li>
        <li>Layer Collision Matrix instead of manual collision checks</li>
        <li>Profiling CPU, GC, memory, and network traffic regularly</li>
    </ul>

    <p>
        All optimization decisions are based on measurements,
        not assumptions.
    </p>
</section>

<!-- ================= BACKEND ================= -->
<section>
    <h3>5. Backend & Data Flow</h3>
    <p>
        I integrate backend systems to support
        <strong>real production requirements</strong>.
    </p>

    <ul>
        <li>Node.js + Express REST APIs</li>
        <li>MongoDB for persistent game data</li>
        <li>Firebase authentication & cloud services</li>
        <li>Secure UnityWebRequest-based communication</li>
    </ul>

    <p>
        Client-server data contracts are designed carefully
        to ensure version compatibility and stability.
    </p>
</section>

<!-- ================= THINKING ================= -->
<section>
    <h3>6. How I Think as an Engineer</h3>
    <ul>
        <li>Build systems that are easy to extend, not just finish</li>
        <li>Prefer clarity and correctness over clever shortcuts</li>
        <li>Optimize based on data, not intuition</li>
        <li>Write code juniors can learn from and seniors can trust</li>
    </ul>

    <p>
        My long-term goal is to grow into a
        <strong>game systems architect</strong>
        building multiplayer games that scale technically and creatively.
    </p>
</section>

<!-- ================= CTA ================= -->
<section>
    <div style="text-align:center;">
        <a href="projects.html" class="btn primary">See Engineering in Action</a>
        <a href="contact.html" class="btn secondary">Let’s Talk</a>
    </div>
</section>

<!-- ================= FOOTER ================= -->
<footer>
    © 2025 Nikhil Chaudhary | Engineering & Architecture
</footer>

<!-- JS -->
<script src="js/main.js"></script>
</body>
</html>
